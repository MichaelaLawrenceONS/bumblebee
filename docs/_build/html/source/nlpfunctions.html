

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>nlpfunctions package &mdash; nlpfunctions 0.0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> nlpfunctions
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">nlpfunctions package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-nlpfunctions.basicnlp">nlpfunctions.basicnlp module</a></li>
<li><a class="reference internal" href="#nlpfunctions-similarities-module">nlpfunctions.similarities module</a></li>
<li><a class="reference internal" href="#module-nlpfunctions.spellcheck">nlpfunctions.spellcheck module</a></li>
<li><a class="reference internal" href="#module-nlpfunctions.summarization">nlpfunctions.summarization module</a></li>
<li><a class="reference internal" href="#module-nlpfunctions.topicmod">nlpfunctions.topicmod module</a></li>
<li><a class="reference internal" href="#module-nlpfunctions.utils">nlpfunctions.utils module</a></li>
<li><a class="reference internal" href="#module-nlpfunctions">Module contents</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">nlpfunctions</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>nlpfunctions package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/source/nlpfunctions.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="nlpfunctions-package">
<h1>nlpfunctions package<a class="headerlink" href="#nlpfunctions-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-nlpfunctions.basicnlp">
<span id="nlpfunctions-basicnlp-module"></span><h2>nlpfunctions.basicnlp module<a class="headerlink" href="#module-nlpfunctions.basicnlp" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nlpfunctions.basicnlp.POS_tagging">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">POS_tagging</code><span class="sig-paren">(</span><em>list_of_lists_of_tokens</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.POS_tagging" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list with POS-tags/words tuples for the specified text, using Penn Treebank</p>
<ul class="simple">
<li>list_of_lists_of_tokens : : dataframe column or variable containing a list of word-token lists, with each sublist being a sentence in a paragraph text</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.break_compound_words">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">break_compound_words</code><span class="sig-paren">(</span><em>list_of_lists_of_tokens</em>, <em>compound_symbol='-'</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.break_compound_words" title="Permalink to this definition">¶</a></dt>
<dd><p>Break words of the compound form word1&lt;symbol&gt;word2 into the constituting words,
then remove resulting empty strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>list_of_lists_of_tokens</strong> (<em>dataframe column or variable containing a list of word-token lists, with each sublist being a sentence in a paragraph text</em>)</li>
<li><strong>compound-simbol</strong> (<em>compound symbol word1&lt;symbol&gt;word2 to be broken, default is ‘-‘</em>)</li>
<li><strong>OUTPUT</strong> (<em>the original list of word-token lists with the specified compound words broken down in their components</em>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.classify_subjectivity">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">classify_subjectivity</code><span class="sig-paren">(</span><em>list_of_scores</em>, <em>threshold=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.classify_subjectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a binary score (1 = subjective, 0 = objective) for each sentence in the input text
based on the sentence’s subjectivity score. Scores &gt; threshold are classified as subjecive.</p>
<ul class="simple">
<li>list_of_scores : a dataframe column containing a list of subjectivity scores in each row or a variable of such a lis of scores</li>
<li>threshold : the cut off value above which a sentence is classified as subjective between [0.0, 1.0] - default is 0.5</li>
<li>OUTPUT : a dataframe column consisting of a list of 1’s/0’s on each row</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.count_pos">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">count_pos</code><span class="sig-paren">(</span><em>list_of_lists_of_pos_tuples</em>, <em>pos_to_cnt=''</em>, <em>normalise=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.count_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Return count or porportion of specified part-of-speech in each text</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>- list_of_lists_of_pos_tuples</strong> (<em>dataframe column whose cells contain lists of NLTK-produced POS,</em>) – where each list is one sentence in a paragraph text</li>
<li><strong>- pos</strong> (<em>part-of-speech to count, specified by their initial: ‘J’ for adjs, ‘R’ for adverbs, ‘N’ for nouns, ‘V’ for verbs</em>)</li>
<li><strong>- normalise</strong> (<em>whether to return normalised counts (i.e., proportion), default is True</em>)</li>
<li><strong>- OUTPUT</strong> (<em>list of integers, each being the count/proportion of pos in each paragraph text</em>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.count_punkt">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">count_punkt</code><span class="sig-paren">(</span><em>list_of_lists_of_tokens</em>, <em>punkt_list=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.count_punkt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return count of “meaningful” punctuation symbols in each text</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>- list_of_lists_of_tokens</strong> (<em>dataframe column whose cells contain lists of words/tokens (one list for each sentence making up the cell text)</em>)</li>
<li><strong>- punkt_list</strong> (<em>list of punctuation symbols to count (e.g., [“!”, “?”, “…”])</em>)</li>
<li><strong>- OUTPUT</strong> (<em>pandas Series of integer, each being the count of punctuation in each text cell</em>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.count_words">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">count_words</code><span class="sig-paren">(</span><em>list_of_lists_of_tokens</em>, <em>exclude_punkt=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.count_words" title="Permalink to this definition">¶</a></dt>
<dd><p>Return count of words in each text</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>- list_of_lists_of_tokens</strong> (<em>dataframe column whose cells contain lists of word-tokenised sentences</em>)</li>
<li><strong>- exclude_punkt</strong> (<em>whether to exlcude punctuation symbols from the count, default is True</em>)</li>
<li><strong>- OUTPUT</strong> (<em>pandas Series of integer, each being the count of words in each text cell</em>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.fix_neg_auxiliary">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">fix_neg_auxiliary</code><span class="sig-paren">(</span><em>list_of_lists_of_tokens</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.fix_neg_auxiliary" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace contracted negative forms of auxiliary verbs with negation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>list_of_lists_of_tokens</strong> (<em>dataframe column or variable containing a list of word-token lists, with each sublist being a sentence in a paragraph text</em>)</li>
<li><strong>OUPUT</strong> (<em>the original list of word-token lists with the negative forms of auxiliary verbs replaced</em>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.get_sentiment_score_TB">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">get_sentiment_score_TB</code><span class="sig-paren">(</span><em>INPUT</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.get_sentiment_score_TB" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate sentiment analysis score
for each sentence in each cell (text/answer) in the specified dataframe column.</p>
<p>Return a list of scores, one score for each sentence in the column cell.
If text is empty, return NaN.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>- list_of_string</strong> (<em>a dataframe column or variable containing the text stored as a list of string sentences for which to compute sentiment score (at sentence level).</em>)</li>
<li><strong>- OUTPUT</strong> (<em>a list of sentiment polarity score from -1 (negative) to 1 (positive), one for each sentence making up the text</em>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.get_sentiment_score_VDR">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">get_sentiment_score_VDR</code><span class="sig-paren">(</span><em>list_of_strings</em>, <em>score_type='compound'</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.get_sentiment_score_VDR" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate nltk Vader sentiment analysis score (score_type: ‘compound’ default, ‘pos’, ‘neg’)
for each sentence in a paragraph text. The input must be a list of string sentences.</p>
<p>Return a list of scores (as float), one score for each sentence in the paragraph text.
If text is empty, return NaN.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>list_of_strings</strong> (<em>name of the dataframe column or variable containing the text stored as a list of string sentences for which to</em>)</li>
<li><strong>compute sentence-level sentiment score.</strong></li>
<li><strong>score_type</strong> (<em>‘compound’ (default), ‘pos’ or ‘neg’</em>)</li>
<li><strong>OUTPUT</strong> (<em>a list of sentiment scores (as floats)</em>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.get_sentiment_stricter_threshold">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">get_sentiment_stricter_threshold</code><span class="sig-paren">(</span><em>list_of_scores</em>, <em>polarity_threshold=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.get_sentiment_stricter_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of lists containing only sentiment polarity scores that meet the
polarity threshold:</p>
<p>scores &gt; 1 * threshold*1 (for positive scores)
scores &lt; -1 * threshold (for negative scores)
-1 * threshold &lt;= score &lt;= 1 * threshold are returned as NaN</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>- list_of_scores</strong> (<em>a dataframe column consisting of a list of sentiment polarity scores in the range [-1, 1] in each row</em>)</li>
<li><strong>- polarity_threshold</strong> (<em>the cut off value to consider a score as positive or negative</em>)</li>
<li><strong>- OUTPUT</strong> (<em>a dataframe column consisting of a list of sentiment polarity scores tha meet the stricter threshold</em>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.get_subjectivity">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">get_subjectivity</code><span class="sig-paren">(</span><em>list_of_string</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.get_subjectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subjectivity score for each sentence in the input text.</p>
<ul class="simple">
<li>list_of_string : a dataframe column or variable containing the text stored as a list of string sentences for which to compute subjectivity score.</li>
<li>OUTPUT : a list of subjectivity scores for each row (one score per each sentence in the cell)</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.get_wordnet_pos">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">get_wordnet_pos</code><span class="sig-paren">(</span><em>treebank_tag</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.get_wordnet_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Wordnet POS tags from Penn Treebank tags</p>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.is_part_string">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">is_part_string</code><span class="sig-paren">(</span><em>text</em>, <em>target_string</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.is_part_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if targe_string is contained in text.
Example: is_part_string(‘Hi &#64;ONS’, target_string=’&#64;’) ==&gt; True</p>
<p>text : a string of text
target_string : a string of characters</p>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.keep_only_strict_polarity_sents">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">keep_only_strict_polarity_sents</code><span class="sig-paren">(</span><em>list_of_strings</em>, <em>polarity_threshold=0.3</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.keep_only_strict_polarity_sents" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Return a list of lists containing only sentences with a polarity score that meets the thresholds:</dt>
<dd>if positive, score(sentence) &gt; 1*polarity_threshold
if negative, score(sentence) &lt; -1*polarity_threshold</dd>
</dl>
<p>Sentences’ compound polarity score is calculated using nltk Vader.</p>
<ul class="simple">
<li>list_of_strings : a dataframe column consisting of a list of strings in each row, where each string is a sentence in the text.</li>
<li>polarity_threshold : the stricter threshold that decides whether a sentence has a positive or negative polarity, default is 0.3</li>
<li>OUTPUT : a list of string sentences for each row</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.lemmatise">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">lemmatise</code><span class="sig-paren">(</span><em>list_of_lists_of_pos_tuples</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.lemmatise" title="Permalink to this definition">¶</a></dt>
<dd><p>Return lemmas from word-POS tag tuples, using Wordnet POS tags.
When no wordnet POS tag is avalable, it returns the original word.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>POStag_col</strong> (<em>dataframe column containig lists of (word, POS) tuples</em>)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.mark_neg">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">mark_neg</code><span class="sig-paren">(</span><em>list_of_lists_of_tokens</em>, <em>double_neg_flip=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.mark_neg" title="Permalink to this definition">¶</a></dt>
<dd><p>Return count of words in each text</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>- list_of_lists_of_tokens</strong> (<em>dataframe column whose cells contain lists of word-tokenised sentences</em>)</li>
<li><strong>- OUTPUT</strong></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.remove_objective_sents">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">remove_objective_sents</code><span class="sig-paren">(</span><em>list_of_strings</em>, <em>threshold=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.remove_objective_sents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of lists containing only sentences with a subjective score, where
subjectivity is defined as &gt; threshold.</p>
<ul class="simple">
<li>list_of_string : a dataframe column or variable containing the text stored as a list of string sentences for which to compute subjectivity score.</li>
<li><dl class="first docutils">
<dt>threshold <span class="classifier-delimiter">:</span> <span class="classifier">the cut off value above which a sentence is classified as subjective between [0.0, 1.0]</span></dt>
<dd>default is 0.5</dd>
</dl>
</li>
<li>OUTPUT : a dataframe column consisting of a list of string setences in each row</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.remove_punctuation">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">remove_punctuation</code><span class="sig-paren">(</span><em>list_of_string</em>, <em>item_to_keep=''</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.remove_punctuation" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove punctuation from a list of strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>- list_of_string</strong> (<em>a dataframe column or variable containing the text stored as a list of string sentences</em>)</li>
<li><strong>- item_to_keep</strong> (<em>a string of punctuation signs you want to keep in text (e.g., ‘!?.,:;’)</em>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.remove_stopwords">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">remove_stopwords</code><span class="sig-paren">(</span><em>list_of_lists_of_tokens, stopwords_list=['i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', &quot;you're&quot;, &quot;you've&quot;, &quot;you'll&quot;, &quot;you'd&quot;, 'your', 'yours', 'yourself', 'yourselves', 'he', 'him', 'his', 'himself', 'she', &quot;she's&quot;, 'her', 'hers', 'herself', 'it', &quot;it's&quot;, 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves', 'what', 'which', 'who', 'whom', 'this', 'that', &quot;that'll&quot;, 'these', 'those', 'am', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'having', 'do', 'does', 'did', 'doing', 'a', 'an', 'the', 'and', 'but', 'if', 'or', 'because', 'as', 'until', 'while', 'of', 'at', 'by', 'for', 'with', 'about', 'against', 'between', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'to', 'from', 'up', 'down', 'in', 'out', 'on', 'off', 'over', 'under', 'again', 'further', 'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'any', 'both', 'each', 'few', 'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than', 'too', 'very', 's', 't', 'can', 'will', 'just', 'don', &quot;don't&quot;, 'should', &quot;should've&quot;, 'now', 'd', 'll', 'm', 'o', 're', 've', 'y', 'ain', 'aren', &quot;aren't&quot;, 'couldn', &quot;couldn't&quot;, 'didn', &quot;didn't&quot;, 'doesn', &quot;doesn't&quot;, 'hadn', &quot;hadn't&quot;, 'hasn', &quot;hasn't&quot;, 'haven', &quot;haven't&quot;, 'isn', &quot;isn't&quot;, 'ma', 'mightn', &quot;mightn't&quot;, 'mustn', &quot;mustn't&quot;, 'needn', &quot;needn't&quot;, 'shan', &quot;shan't&quot;, 'shouldn', &quot;shouldn't&quot;, 'wasn', &quot;wasn't&quot;, 'weren', &quot;weren't&quot;, 'won', &quot;won't&quot;, 'wouldn', &quot;wouldn't&quot;], keep_neg=True, words_to_keep=[], extra_stopwords=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.remove_stopwords" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove specified stop-words.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>- list_of_lists_of_tokens</strong> (<em>: dataframe column or variable containing a list of word-token lists, with each sublist being a sentence in a paragraph text</em>)</li>
<li><strong>- stopwords_list</strong> (<em>(default) English stopwords from. nltk.corpus</em>)</li>
<li><strong>- keep_neg</strong> (<em>whether to remove negation from list of stopwords, (default) True</em>)</li>
<li><strong>- words_to_keep</strong> (<em>list of words not to remove from the text (default is empty)</em>)</li>
<li><strong>- extra_stopwords</strong> (<em>list of ad-hoc stopwords to remove from text (default is empty)</em>)</li>
<li><strong>- OUTPUT</strong></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.rescale_to_01">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">rescale_to_01</code><span class="sig-paren">(</span><em>value</em>, <em>min_v</em>, <em>max_v</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.rescale_to_01" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the corresponding value in the range 0-1.
If the original data only contains -1’s and 1’s, then these are return as 0’s and 1’s respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>value</strong> (<em>name of the dataframe column containing the values to be scaled (one score per row)</em>)</li>
<li><strong>min_v</strong> (<em>minimum value in the data</em>)</li>
<li><strong>max_v</strong> (<em>maximum value in the data</em>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.sent_tokenise">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">sent_tokenise</code><span class="sig-paren">(</span><em>string_par</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.sent_tokenise" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to sentence-tokenise a text paragraph of any sentence length.
Return a list of string sentences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>string_par</strong> (<em>name of the dataframe column or string that contains the paragraph text to be sentence-tokenised.</em>)</li>
<li><strong>OUTPUT</strong> (<em>a lis of sring sentences</em>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.to_lower">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">to_lower</code><span class="sig-paren">(</span><em>list_of_lists_of_tokens</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.to_lower" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nlpfunctions.basicnlp.word_tokenise">
<code class="descclassname">nlpfunctions.basicnlp.</code><code class="descname">word_tokenise</code><span class="sig-paren">(</span><em>list_of_strings</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.basicnlp.word_tokenise" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to word-tokenise sentences within a text.
Required input is a list of string sentences, e.g. [‘I love dogs.’, ‘Me too!’]
Returns a list of lists of token words, e.g. [[ ‘I’, ‘love’, ‘dogs’, ‘.’],  [‘Me’, ‘too’, ‘!’]]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>list_of_strings</strong> (<em>name of the dataframe column containing a list of string sentences in each cell or a list of string sentences.</em>)</li>
<li><strong>OUTPUT</strong> (<em>a list of lists of token word. Each sentence’s boundaries are preserved.</em>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="nlpfunctions-similarities-module">
<h2>nlpfunctions.similarities module<a class="headerlink" href="#nlpfunctions-similarities-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-nlpfunctions.spellcheck">
<span id="nlpfunctions-spellcheck-module"></span><h2>nlpfunctions.spellcheck module<a class="headerlink" href="#module-nlpfunctions.spellcheck" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nlpfunctions.spellcheck.correct_text">
<code class="descclassname">nlpfunctions.spellcheck.</code><code class="descname">correct_text</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.spellcheck.correct_text" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nlpfunctions.spellcheck.find_and_print_errors">
<code class="descclassname">nlpfunctions.spellcheck.</code><code class="descname">find_and_print_errors</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.spellcheck.find_and_print_errors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nlpfunctions.spellcheck.infer_spaces">
<code class="descclassname">nlpfunctions.spellcheck.</code><code class="descname">infer_spaces</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.spellcheck.infer_spaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Probabilistically split concatenated words using NLP based on
English Wikipedia uni-gram frequencies.
Ref:https://stackoverflow.com/questions/8870261/</p>
</dd></dl>

</div>
<div class="section" id="module-nlpfunctions.summarization">
<span id="nlpfunctions-summarization-module"></span><h2>nlpfunctions.summarization module<a class="headerlink" href="#module-nlpfunctions.summarization" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nlpfunctions.summarization.extract_candidate_words">
<code class="descclassname">nlpfunctions.summarization.</code><code class="descname">extract_candidate_words</code><span class="sig-paren">(</span><em>text</em>, <em>good_tags={'NN'</em>, <em>'NNPS'</em>, <em>'JJR'</em>, <em>'NNP'</em>, <em>'JJ'</em>, <em>'NNS'</em>, <em>'JJS'}</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.summarization.extract_candidate_words" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nlpfunctions.summarization.score_keyphrases_by_textrank">
<code class="descclassname">nlpfunctions.summarization.</code><code class="descname">score_keyphrases_by_textrank</code><span class="sig-paren">(</span><em>text</em>, <em>n_keywords=0.05</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.summarization.score_keyphrases_by_textrank" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nlpfunctions.topicmod">
<span id="nlpfunctions-topicmod-module"></span><h2>nlpfunctions.topicmod module<a class="headerlink" href="#module-nlpfunctions.topicmod" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nlpfunctions.topicmod.lda_dtm2df">
<code class="descclassname">nlpfunctions.topicmod.</code><code class="descname">lda_dtm2df</code><span class="sig-paren">(</span><em>lda_doc_topic_matrix</em>, <em>num_topics</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.topicmod.lda_dtm2df" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the doc-topic probabilities matrix into a pandas dataframe:
rows are documents, columns are topics storing the probabilities for each doc-topic.</p>
<ul class="simple">
<li>lda_doc_topic_matrix : the doc-topic prob matrix resulting from of models.LdaModel[bow_corpus]</li>
<li>num_topics : number of topics used in the lda model</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.topicmod.lda_ranked_topics2df">
<code class="descclassname">nlpfunctions.topicmod.</code><code class="descname">lda_ranked_topics2df</code><span class="sig-paren">(</span><em>lda_mod</em>, <em>corpus</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.topicmod.lda_ranked_topics2df" title="Permalink to this definition">¶</a></dt>
<dd><p>For each document, return ranked topics and their probabilities, and convert it to
a pandas dataframe:</p>
<blockquote>
<div>rows are documents, column “ranked_topics_lda” contains the documents’ tuple of ranked topics,
column “ranked_topics_ps_lda” contains the tuple of associated topics’ probabilities</div></blockquote>
<ul class="simple">
<li>lda_mod : gemsin lda model</li>
<li>corpus : bag-of-words corpus of documents resulting from [dictionary.doc2bow(text) for text in corpus]</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.topicmod.lda_topic_top_words">
<code class="descclassname">nlpfunctions.topicmod.</code><code class="descname">lda_topic_top_words</code><span class="sig-paren">(</span><em>lda_mod</em>, <em>n_top_words=6</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.topicmod.lda_topic_top_words" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the top n words for each K topic, and convert results in a dictionary:
- keys are the K topics
- 2 values: first value is the list of top words, second value is the list of corresponding word probabilities</p>
<p>lda mod : gensim lda model
n_top_words : number of top words per topic to be exracted</p>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.topicmod.nmf_dtm2df">
<code class="descclassname">nlpfunctions.topicmod.</code><code class="descname">nmf_dtm2df</code><span class="sig-paren">(</span><em>nmf_doc_topic_matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.topicmod.nmf_dtm2df" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the doc-topic probabilities matrix into a pandas dataframe:
rows are documents, columns are topics storing the probabilities for each doc-topic.</p>
<ul class="simple">
<li>nmf_doc_topic_matrix : NMF doc-topic matrix, or its standardised version</li>
<li>num_topics : number of topics used in the lda model</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.topicmod.nmf_ranked_topics2df">
<code class="descclassname">nlpfunctions.topicmod.</code><code class="descname">nmf_ranked_topics2df</code><span class="sig-paren">(</span><em>nmf_doc_topic_matrix</em>, <em>num_topics</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.topicmod.nmf_ranked_topics2df" title="Permalink to this definition">¶</a></dt>
<dd><p>For each document, return ranked topics and their probabilities, and convert it to
a pandas dataframe:</p>
<blockquote>
<div>rows are documents, column “ranked_topics_nmf” contains the documents’ tuple of ranked topics,
column “ranked_topics_ps_nmf” contains the tuple of associated topics’ probabilities</div></blockquote>
<ul class="simple">
<li>nmf_doc_topic_matrix : NMF doc-topic matrix, or its standardised version</li>
<li>num_topics : number of topics</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.topicmod.nmf_topic_top_words">
<code class="descclassname">nlpfunctions.topicmod.</code><code class="descname">nmf_topic_top_words</code><span class="sig-paren">(</span><em>topic_term_matrix</em>, <em>vocabulary</em>, <em>n_top_words=6</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.topicmod.nmf_topic_top_words" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the top n words for each K topic, and convert results in a dictionary:
- keys are the K topics
- 2 values: first value is the list of top words, second value is the list of corresponding word probabilities</p>
<ul class="simple">
<li>topic_term_matrix: topic-term matrix extracting from <a href="#id1"><span class="problematic" id="id2">NMF.components_</span></a> or its sandardised version</li>
<li>vocabulary : tuple of dictionary terms resulting from np.array(vectorizer.get_feature_names())</li>
<li>n_top_words : number of top words per topic to be exracted</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.topicmod.standardise_dtm_nmf">
<code class="descclassname">nlpfunctions.topicmod.</code><code class="descname">standardise_dtm_nmf</code><span class="sig-paren">(</span><em>nmf_doc_topic_matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.topicmod.standardise_dtm_nmf" title="Permalink to this definition">¶</a></dt>
<dd><p>Standardise NMF doc_topic matrix so that the topic probabilities for each doc sum to one</p>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.topicmod.standardise_twm_nmf">
<code class="descclassname">nlpfunctions.topicmod.</code><code class="descname">standardise_twm_nmf</code><span class="sig-paren">(</span><em>nmf_model</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.topicmod.standardise_twm_nmf" title="Permalink to this definition">¶</a></dt>
<dd><p>Standardise NMF topic-word matrix so that word probabilities for each doc sum up to 1</p>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.topicmod.topictopwords_dict2df">
<code class="descclassname">nlpfunctions.topicmod.</code><code class="descname">topictopwords_dict2df</code><span class="sig-paren">(</span><em>topic_top_words_dict</em>, <em>orig_dataset=None</em>, <em>tech=''</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.topicmod.topictopwords_dict2df" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the dictionary containing topics’ top words into a pandas dataframe with K*2 columns:
- k columns containing the top n word for each kth topic
- k columns containing the associating top-word probabilities</p>
<p>If a dataframe for the orig_dataset parameter is provided, then a final dataframe is returned
with the same row dimention as the orig_dataset so that they can be merged.</p>
<ul class="simple">
<li>topic_top_words_dict : a dictionary with topic idx as keys, and list of top words and list of their probabilities as two values</li>
<li>orig_dataset : original dataset containing texts used for topic modelling, one text per row</li>
<li>tech (optional): a string specifying the topic modelling technique used to be added to column names (e.g., ‘lda’ or ‘nmf’)</li>
</ul>
</dd></dl>

</div>
<div class="section" id="module-nlpfunctions.utils">
<span id="nlpfunctions-utils-module"></span><h2>nlpfunctions.utils module<a class="headerlink" href="#module-nlpfunctions.utils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nlpfunctions.utils.combine_2fs">
<code class="descclassname">nlpfunctions.utils.</code><code class="descname">combine_2fs</code><span class="sig-paren">(</span><em>f</em>, <em>g</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.utils.combine_2fs" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to chain two functions.</p>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.utils.combine_functions">
<code class="descclassname">nlpfunctions.utils.</code><code class="descname">combine_functions</code><span class="sig-paren">(</span><em>*f_args</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.utils.combine_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to combine an n  number of function together.
First to last function to apply from left to right. I.e., f, g for g(f(x))</p>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.utils.combine_functions_output_series">
<code class="descclassname">nlpfunctions.utils.</code><code class="descname">combine_functions_output_series</code><span class="sig-paren">(</span><em>*f_args</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.utils.combine_functions_output_series" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nlpfunctions.utils.flattenIrregularListOfLists">
<code class="descclassname">nlpfunctions.utils.</code><code class="descname">flattenIrregularListOfLists</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.utils.flattenIrregularListOfLists" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to flatten a list of lists that is nested /irregular  eg  [1,2,[],[[3]]],4,[5,6]]
Returns a flattened list generator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>INPUT</strong> (<em>a ( nested) list of lists</em>)</li>
<li><strong>OUTPUT</strong> (<em>a flattened list generator</em>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.utils.list2string">
<code class="descclassname">nlpfunctions.utils.</code><code class="descname">list2string</code><span class="sig-paren">(</span><em>list_of_strings</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.utils.list2string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string from a list of strings.</p>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.utils.merge_dfs">
<code class="descclassname">nlpfunctions.utils.</code><code class="descname">merge_dfs</code><span class="sig-paren">(</span><em>*dfs</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.utils.merge_dfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge datasets on index.
Note: same index must refer to the same sample across all datasets.</p>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.utils.output_series">
<code class="descclassname">nlpfunctions.utils.</code><code class="descname">output_series</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.utils.output_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes strings and returns a pd.Series</p>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.utils.series_output">
<code class="descclassname">nlpfunctions.utils.</code><code class="descname">series_output</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.utils.series_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for turning the outcome of a function into a pandas.Series</p>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.utils.string_to_series_out">
<code class="descclassname">nlpfunctions.utils.</code><code class="descname">string_to_series_out</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.utils.string_to_series_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for turning the outcome of a function into a pandas.Series
It first checks whether the outcome is already a pandas.Series or not</p>
</dd></dl>

<dl class="function">
<dt id="nlpfunctions.utils.word_tokens2string_sentences">
<code class="descclassname">nlpfunctions.utils.</code><code class="descname">word_tokens2string_sentences</code><span class="sig-paren">(</span><em>list_of_lists_of_tokens</em><span class="sig-paren">)</span><a class="headerlink" href="#nlpfunctions.utils.word_tokens2string_sentences" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list containing a single string of text for each word-tokenised sentence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>- list_of_lists_of_tokens</strong> (<em>dataframe column or variable containing a list of word-token lists, with each sublist being a sentence in a paragraph text</em>)</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-nlpfunctions">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-nlpfunctions" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Theodore Manassis &amp; Alessia Tosi.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.0.1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>